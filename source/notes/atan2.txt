Fast atan2 for angular gradients
================================

Calculate the angle of the line (0,0)-->(x,y)

Goals...
1. make it branch free, for easy SIMD,
2. fast aproximation that is just good enough

Details...
==========

Calculate the angle for the first quadrant (x >= 0, and y >= 0), and flip / mirror that to get the other quadrants.

We need to convert (x,y) into a "gradient" of sorts, so that all points at a given angle have the same value, and then we can stuff that into a polynomial approximation to get the angle. We would idealy keep this "gradient" normalised, so it's abs() value is never greater than 1. Luckily there's a simple solution...

g = (x-y)/(x+y)

As x and y are always positive g will always be in the range -1..1

In order to avoid posible divide by zero we modify to...

g = (x-y) / max((x+y),0.001)

As the coordinates are pixel coordinates the 0.001 is 1/1000 pixel error for the absolute center of the gradient, which is irrelevant.

We then use a cubic aproximation to map 'g' to the angle. I used curve fitting based on limiting the maximum absolute error to generate the polynomial, max error was 0.315% or 0.28 degrees. Also the even powers in the polynominal tended towards zero so it converged on...

angle = 0.19194811*q^3 - 0.972394341*q + 0.785398163;

given (y,x) 

  ax = abs(x)
  ay = abs(y)
  q = (ax-ay) / max(ax+ay,0.001);
  angle = 0.191948022*q*q*q - 0.972394222*q + 0.785398163;

Now we consider how the sign of x,y maps the angle in the first quadrant to the other quadrants...

x y => actual angle...
+ + => a
- + => PI-a
+ - => 2PI-a
- - => PI+a

Can be done like this...

i) if (sign(x) != sign(y)) angle = -angle;
ii) if (x < 0) angle += PI

note: We can ignore the 2PI term as the angle will masked to modulus 2PI anyway.

We can use bitwise ops on the input floats to do i)

uint s = (x ^ y) & 0x80000000
angle = angle | s;

the second part ii) can be done in integer

uint o = (x & 0x80000000) >> 22
angle += o;

Basically PI maps to half the length of the lookup table so we mask and shift the sign bit into that position so we can conditionaly add based on the sign of x

======

The 2PI term can be ignored as it's all modulus 2PI anyway

x y => actual angle...
+ + => a
- + => PI-a
+ - => -a
- - => PI+a

So if we convert sign bits into two masks...

xmsk = x sar 31
ymsk = y sar 31

then we can flip the sign of 'a' thus..

a = a ^ (xmsk ^ ymsk)

and we can add the PI term thus

a = a ^ (xmsk << 8)
